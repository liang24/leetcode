回溯算法
---

回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 “回溯” 返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为 “回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。

回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。

### 1.DFS 和回溯算法区别

DFS 是一个劲的往某一个方向搜索，而回溯算法建立在 DFS 基础之上的，但不同的是在搜索过程中，达到结束条件后，恢复状态，回溯上一层，再次搜索。因此回溯算法与 DFS 的区别就是有无状态重置

### 2.何时使用回溯算法

当问题需要 "回头"，以此来查找出所有的解的时候，使用回溯算法。即满足结束条件或者发现不是正确路径的时候(走不通)，要撤销选择，回退到上一个状态，继续尝试，直到找出所有解为止

### 3.怎么样写回溯算法(从上而下，※代表难点，根据题目而变化)

1. 画出递归树，找到状态变量(回溯函数的参数)，这一步非常重要※
2. 根据题意，确立结束条件
3. 找准选择列表(与函数参数相关)，与第一步紧密关联※
4. 判断是否需要剪枝
5. 作出选择，递归调用，进入下一层
6. 撤销选择

### 4. 回溯算法模板

```python
result = [] 
def backtrack(路径, 选择列表): 
	if 满足结束条件: 
		result.add(路径) 
		return 
	for 选择 in 选择列表: 
		做选择 
		backtrack(路径, 选择列表) 
		撤销选择
```

### 5.回溯问题的类型

这里先给出，我总结的回溯问题类型，并给出相应的 leetcode题目(一直更新)，然后再说如何去编写。特别关注搜索类型的，搜索类的搞懂，你就真的搞懂回溯算法了,，是前面两类是基础，帮助你培养思维。

类型 | 题目链接
---|---
子集、组合 | [子集](subsets/README.md)、[子集 II](subsets-ii/README.md)、[组合](combinations/README.md)、[组合总和](combination-sum/README.md)、[组合总和 II](combination-sum-ii/README.md)
全排列 | 全排列、全排列 II、[字符串的全排列](zi-fu-chuan-de-pai-lie-lcof/README.md)、字母大小写全排列
搜索 | 解数独、单词搜索、[N皇后](eight-queens-lcci/README.md)、分割回文串、二进制手表

注意：子集、组合与排列是不同性质的概念。子集、组合是无关顺序的，而排列是和元素顺序有关的，如 [1，2] 和 [2，1] 是同一个组合(子集)，但 [1,2] 和 [2,1] 是两种不一样的排列！！！！因此被分为两类问题

### 参考资料

- [C++ 总结了回溯问题类型 带你搞懂回溯算法(大量例题)](https://leetcode-cn.com/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/)
